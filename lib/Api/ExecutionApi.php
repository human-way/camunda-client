<?php
/**
 * ExecutionApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.15.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.2.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ExecutionApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ExecutionApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createIncident
     *
     * Create Incident
     *
     * @param  string $id The id of the execution to create a new incident for. (required)
     * @param  \OpenAPI\Client\Model\CreateIncidentDto $create_incident_dto create_incident_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IncidentDto|\OpenAPI\Client\Model\ExceptionDto
     */
    public function createIncident($id, $create_incident_dto = null)
    {
        list($response) = $this->createIncidentWithHttpInfo($id, $create_incident_dto);
        return $response;
    }

    /**
     * Operation createIncidentWithHttpInfo
     *
     * Create Incident
     *
     * @param  string $id The id of the execution to create a new incident for. (required)
     * @param  \OpenAPI\Client\Model\CreateIncidentDto $create_incident_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IncidentDto|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createIncidentWithHttpInfo($id, $create_incident_dto = null)
    {
        $request = $this->createIncidentRequest($id, $create_incident_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IncidentDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IncidentDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IncidentDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IncidentDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createIncidentAsync
     *
     * Create Incident
     *
     * @param  string $id The id of the execution to create a new incident for. (required)
     * @param  \OpenAPI\Client\Model\CreateIncidentDto $create_incident_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createIncidentAsync($id, $create_incident_dto = null)
    {
        return $this->createIncidentAsyncWithHttpInfo($id, $create_incident_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createIncidentAsyncWithHttpInfo
     *
     * Create Incident
     *
     * @param  string $id The id of the execution to create a new incident for. (required)
     * @param  \OpenAPI\Client\Model\CreateIncidentDto $create_incident_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createIncidentAsyncWithHttpInfo($id, $create_incident_dto = null)
    {
        $returnType = '\OpenAPI\Client\Model\IncidentDto';
        $request = $this->createIncidentRequest($id, $create_incident_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createIncident'
     *
     * @param  string $id The id of the execution to create a new incident for. (required)
     * @param  \OpenAPI\Client\Model\CreateIncidentDto $create_incident_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createIncidentRequest($id, $create_incident_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createIncident'
            );
        }

        $resourcePath = '/execution/{id}/create-incident';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($create_incident_dto)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_incident_dto));
            } else {
                $httpBody = $create_incident_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteLocalExecutionVariable
     *
     * Delete Local Execution Variable
     *
     * @param  string $id The id of the execution to delete the variable from. (required)
     * @param  string $var_name The name of the variable to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteLocalExecutionVariable($id, $var_name)
    {
        $this->deleteLocalExecutionVariableWithHttpInfo($id, $var_name);
    }

    /**
     * Operation deleteLocalExecutionVariableWithHttpInfo
     *
     * Delete Local Execution Variable
     *
     * @param  string $id The id of the execution to delete the variable from. (required)
     * @param  string $var_name The name of the variable to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteLocalExecutionVariableWithHttpInfo($id, $var_name)
    {
        $request = $this->deleteLocalExecutionVariableRequest($id, $var_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteLocalExecutionVariableAsync
     *
     * Delete Local Execution Variable
     *
     * @param  string $id The id of the execution to delete the variable from. (required)
     * @param  string $var_name The name of the variable to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLocalExecutionVariableAsync($id, $var_name)
    {
        return $this->deleteLocalExecutionVariableAsyncWithHttpInfo($id, $var_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLocalExecutionVariableAsyncWithHttpInfo
     *
     * Delete Local Execution Variable
     *
     * @param  string $id The id of the execution to delete the variable from. (required)
     * @param  string $var_name The name of the variable to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLocalExecutionVariableAsyncWithHttpInfo($id, $var_name)
    {
        $returnType = '';
        $request = $this->deleteLocalExecutionVariableRequest($id, $var_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteLocalExecutionVariable'
     *
     * @param  string $id The id of the execution to delete the variable from. (required)
     * @param  string $var_name The name of the variable to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteLocalExecutionVariableRequest($id, $var_name)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteLocalExecutionVariable'
            );
        }
        // verify the required parameter 'var_name' is set
        if ($var_name === null || (is_array($var_name) && count($var_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $var_name when calling deleteLocalExecutionVariable'
            );
        }

        $resourcePath = '/execution/{id}/localVariables/{varName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($var_name !== null) {
            $resourcePath = str_replace(
                '{' . 'varName' . '}',
                ObjectSerializer::toPathValue($var_name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExecution
     *
     * Get Execution
     *
     * @param  string $id The id of the execution to be retrieved. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExecutionDto|\OpenAPI\Client\Model\ExceptionDto
     */
    public function getExecution($id)
    {
        list($response) = $this->getExecutionWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getExecutionWithHttpInfo
     *
     * Get Execution
     *
     * @param  string $id The id of the execution to be retrieved. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExecutionDto|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExecutionWithHttpInfo($id)
    {
        $request = $this->getExecutionRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ExecutionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExecutionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ExecutionDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExecutionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExecutionAsync
     *
     * Get Execution
     *
     * @param  string $id The id of the execution to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExecutionAsync($id)
    {
        return $this->getExecutionAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExecutionAsyncWithHttpInfo
     *
     * Get Execution
     *
     * @param  string $id The id of the execution to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExecutionAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\ExecutionDto';
        $request = $this->getExecutionRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExecution'
     *
     * @param  string $id The id of the execution to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getExecutionRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getExecution'
            );
        }

        $resourcePath = '/execution/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExecutions
     *
     * Get Executions
     *
     * @param  string $business_key Filter by the business key of the process instances the executions belong to. (optional)
     * @param  string $process_definition_id Filter by the process definition the executions run on. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the executions run on. (optional)
     * @param  string $process_instance_id Filter by the id of the process instance the execution belongs to. (optional)
     * @param  string $activity_id Filter by the id of the activity the execution currently executes. (optional)
     * @param  string $signal_event_subscription_name Select only those executions that expect a signal of the given name. (optional)
     * @param  string $message_event_subscription_name Select only those executions that expect a message of the given name. (optional)
     * @param  bool $active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)
     * @param  string $variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExecutionDto[]|\OpenAPI\Client\Model\ExceptionDto
     */
    public function getExecutions($business_key = null, $process_definition_id = null, $process_definition_key = null, $process_instance_id = null, $activity_id = null, $signal_event_subscription_name = null, $message_event_subscription_name = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        list($response) = $this->getExecutionsWithHttpInfo($business_key, $process_definition_id, $process_definition_key, $process_instance_id, $activity_id, $signal_event_subscription_name, $message_event_subscription_name, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $sort_by, $sort_order, $first_result, $max_results);
        return $response;
    }

    /**
     * Operation getExecutionsWithHttpInfo
     *
     * Get Executions
     *
     * @param  string $business_key Filter by the business key of the process instances the executions belong to. (optional)
     * @param  string $process_definition_id Filter by the process definition the executions run on. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the executions run on. (optional)
     * @param  string $process_instance_id Filter by the id of the process instance the execution belongs to. (optional)
     * @param  string $activity_id Filter by the id of the activity the execution currently executes. (optional)
     * @param  string $signal_event_subscription_name Select only those executions that expect a signal of the given name. (optional)
     * @param  string $message_event_subscription_name Select only those executions that expect a message of the given name. (optional)
     * @param  bool $active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)
     * @param  string $variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExecutionDto[]|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExecutionsWithHttpInfo($business_key = null, $process_definition_id = null, $process_definition_key = null, $process_instance_id = null, $activity_id = null, $signal_event_subscription_name = null, $message_event_subscription_name = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $request = $this->getExecutionsRequest($business_key, $process_definition_id, $process_definition_key, $process_instance_id, $activity_id, $signal_event_subscription_name, $message_event_subscription_name, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $sort_by, $sort_order, $first_result, $max_results);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ExecutionDto[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExecutionDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ExecutionDto[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExecutionDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExecutionsAsync
     *
     * Get Executions
     *
     * @param  string $business_key Filter by the business key of the process instances the executions belong to. (optional)
     * @param  string $process_definition_id Filter by the process definition the executions run on. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the executions run on. (optional)
     * @param  string $process_instance_id Filter by the id of the process instance the execution belongs to. (optional)
     * @param  string $activity_id Filter by the id of the activity the execution currently executes. (optional)
     * @param  string $signal_event_subscription_name Select only those executions that expect a signal of the given name. (optional)
     * @param  string $message_event_subscription_name Select only those executions that expect a message of the given name. (optional)
     * @param  bool $active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)
     * @param  string $variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExecutionsAsync($business_key = null, $process_definition_id = null, $process_definition_key = null, $process_instance_id = null, $activity_id = null, $signal_event_subscription_name = null, $message_event_subscription_name = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        return $this->getExecutionsAsyncWithHttpInfo($business_key, $process_definition_id, $process_definition_key, $process_instance_id, $activity_id, $signal_event_subscription_name, $message_event_subscription_name, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $sort_by, $sort_order, $first_result, $max_results)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExecutionsAsyncWithHttpInfo
     *
     * Get Executions
     *
     * @param  string $business_key Filter by the business key of the process instances the executions belong to. (optional)
     * @param  string $process_definition_id Filter by the process definition the executions run on. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the executions run on. (optional)
     * @param  string $process_instance_id Filter by the id of the process instance the execution belongs to. (optional)
     * @param  string $activity_id Filter by the id of the activity the execution currently executes. (optional)
     * @param  string $signal_event_subscription_name Select only those executions that expect a signal of the given name. (optional)
     * @param  string $message_event_subscription_name Select only those executions that expect a message of the given name. (optional)
     * @param  bool $active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)
     * @param  string $variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExecutionsAsyncWithHttpInfo($business_key = null, $process_definition_id = null, $process_definition_key = null, $process_instance_id = null, $activity_id = null, $signal_event_subscription_name = null, $message_event_subscription_name = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $returnType = '\OpenAPI\Client\Model\ExecutionDto[]';
        $request = $this->getExecutionsRequest($business_key, $process_definition_id, $process_definition_key, $process_instance_id, $activity_id, $signal_event_subscription_name, $message_event_subscription_name, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $sort_by, $sort_order, $first_result, $max_results);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExecutions'
     *
     * @param  string $business_key Filter by the business key of the process instances the executions belong to. (optional)
     * @param  string $process_definition_id Filter by the process definition the executions run on. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the executions run on. (optional)
     * @param  string $process_instance_id Filter by the id of the process instance the execution belongs to. (optional)
     * @param  string $activity_id Filter by the id of the activity the execution currently executes. (optional)
     * @param  string $signal_event_subscription_name Select only those executions that expect a signal of the given name. (optional)
     * @param  string $message_event_subscription_name Select only those executions that expect a message of the given name. (optional)
     * @param  bool $active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)
     * @param  string $variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getExecutionsRequest($business_key = null, $process_definition_id = null, $process_definition_key = null, $process_instance_id = null, $activity_id = null, $signal_event_subscription_name = null, $message_event_subscription_name = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {

        $resourcePath = '/execution';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($business_key !== null) {
            if('form' === 'form' && is_array($business_key)) {
                foreach($business_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['businessKey'] = $business_key;
            }
        }
        // query params
        if ($process_definition_id !== null) {
            if('form' === 'form' && is_array($process_definition_id)) {
                foreach($process_definition_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionId'] = $process_definition_id;
            }
        }
        // query params
        if ($process_definition_key !== null) {
            if('form' === 'form' && is_array($process_definition_key)) {
                foreach($process_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionKey'] = $process_definition_key;
            }
        }
        // query params
        if ($process_instance_id !== null) {
            if('form' === 'form' && is_array($process_instance_id)) {
                foreach($process_instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceId'] = $process_instance_id;
            }
        }
        // query params
        if ($activity_id !== null) {
            if('form' === 'form' && is_array($activity_id)) {
                foreach($activity_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['activityId'] = $activity_id;
            }
        }
        // query params
        if ($signal_event_subscription_name !== null) {
            if('form' === 'form' && is_array($signal_event_subscription_name)) {
                foreach($signal_event_subscription_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['signalEventSubscriptionName'] = $signal_event_subscription_name;
            }
        }
        // query params
        if ($message_event_subscription_name !== null) {
            if('form' === 'form' && is_array($message_event_subscription_name)) {
                foreach($message_event_subscription_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['messageEventSubscriptionName'] = $message_event_subscription_name;
            }
        }
        // query params
        if ($active !== null) {
            if('form' === 'form' && is_array($active)) {
                foreach($active as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['active'] = $active;
            }
        }
        // query params
        if ($suspended !== null) {
            if('form' === 'form' && is_array($suspended)) {
                foreach($suspended as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['suspended'] = $suspended;
            }
        }
        // query params
        if ($incident_id !== null) {
            if('form' === 'form' && is_array($incident_id)) {
                foreach($incident_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['incidentId'] = $incident_id;
            }
        }
        // query params
        if ($incident_type !== null) {
            if('form' === 'form' && is_array($incident_type)) {
                foreach($incident_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['incidentType'] = $incident_type;
            }
        }
        // query params
        if ($incident_message !== null) {
            if('form' === 'form' && is_array($incident_message)) {
                foreach($incident_message as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['incidentMessage'] = $incident_message;
            }
        }
        // query params
        if ($incident_message_like !== null) {
            if('form' === 'form' && is_array($incident_message_like)) {
                foreach($incident_message_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['incidentMessageLike'] = $incident_message_like;
            }
        }
        // query params
        if ($tenant_id_in !== null) {
            if('form' === 'form' && is_array($tenant_id_in)) {
                foreach($tenant_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tenantIdIn'] = $tenant_id_in;
            }
        }
        // query params
        if ($variables !== null) {
            if('form' === 'form' && is_array($variables)) {
                foreach($variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variables'] = $variables;
            }
        }
        // query params
        if ($process_variables !== null) {
            if('form' === 'form' && is_array($process_variables)) {
                foreach($process_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processVariables'] = $process_variables;
            }
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_names_ignore_case)) {
                foreach($variable_names_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableNamesIgnoreCase'] = $variable_names_ignore_case;
            }
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_values_ignore_case)) {
                foreach($variable_values_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableValuesIgnoreCase'] = $variable_values_ignore_case;
            }
        }
        // query params
        if ($sort_by !== null) {
            if('form' === 'form' && is_array($sort_by)) {
                foreach($sort_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sortBy'] = $sort_by;
            }
        }
        // query params
        if ($sort_order !== null) {
            if('form' === 'form' && is_array($sort_order)) {
                foreach($sort_order as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sortOrder'] = $sort_order;
            }
        }
        // query params
        if ($first_result !== null) {
            if('form' === 'form' && is_array($first_result)) {
                foreach($first_result as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['firstResult'] = $first_result;
            }
        }
        // query params
        if ($max_results !== null) {
            if('form' === 'form' && is_array($max_results)) {
                foreach($max_results as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxResults'] = $max_results;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExecutionsCount
     *
     * Get Execution Count
     *
     * @param  string $business_key Filter by the business key of the process instances the executions belong to. (optional)
     * @param  string $process_definition_id Filter by the process definition the executions run on. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the executions run on. (optional)
     * @param  string $process_instance_id Filter by the id of the process instance the execution belongs to. (optional)
     * @param  string $activity_id Filter by the id of the activity the execution currently executes. (optional)
     * @param  string $signal_event_subscription_name Select only those executions that expect a signal of the given name. (optional)
     * @param  string $message_event_subscription_name Select only those executions that expect a message of the given name. (optional)
     * @param  bool $active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)
     * @param  string $variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CountResultDto|\OpenAPI\Client\Model\ExceptionDto
     */
    public function getExecutionsCount($business_key = null, $process_definition_id = null, $process_definition_key = null, $process_instance_id = null, $activity_id = null, $signal_event_subscription_name = null, $message_event_subscription_name = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null)
    {
        list($response) = $this->getExecutionsCountWithHttpInfo($business_key, $process_definition_id, $process_definition_key, $process_instance_id, $activity_id, $signal_event_subscription_name, $message_event_subscription_name, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case);
        return $response;
    }

    /**
     * Operation getExecutionsCountWithHttpInfo
     *
     * Get Execution Count
     *
     * @param  string $business_key Filter by the business key of the process instances the executions belong to. (optional)
     * @param  string $process_definition_id Filter by the process definition the executions run on. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the executions run on. (optional)
     * @param  string $process_instance_id Filter by the id of the process instance the execution belongs to. (optional)
     * @param  string $activity_id Filter by the id of the activity the execution currently executes. (optional)
     * @param  string $signal_event_subscription_name Select only those executions that expect a signal of the given name. (optional)
     * @param  string $message_event_subscription_name Select only those executions that expect a message of the given name. (optional)
     * @param  bool $active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)
     * @param  string $variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CountResultDto|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExecutionsCountWithHttpInfo($business_key = null, $process_definition_id = null, $process_definition_key = null, $process_instance_id = null, $activity_id = null, $signal_event_subscription_name = null, $message_event_subscription_name = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null)
    {
        $request = $this->getExecutionsCountRequest($business_key, $process_definition_id, $process_definition_key, $process_instance_id, $activity_id, $signal_event_subscription_name, $message_event_subscription_name, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CountResultDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CountResultDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CountResultDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExecutionsCountAsync
     *
     * Get Execution Count
     *
     * @param  string $business_key Filter by the business key of the process instances the executions belong to. (optional)
     * @param  string $process_definition_id Filter by the process definition the executions run on. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the executions run on. (optional)
     * @param  string $process_instance_id Filter by the id of the process instance the execution belongs to. (optional)
     * @param  string $activity_id Filter by the id of the activity the execution currently executes. (optional)
     * @param  string $signal_event_subscription_name Select only those executions that expect a signal of the given name. (optional)
     * @param  string $message_event_subscription_name Select only those executions that expect a message of the given name. (optional)
     * @param  bool $active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)
     * @param  string $variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExecutionsCountAsync($business_key = null, $process_definition_id = null, $process_definition_key = null, $process_instance_id = null, $activity_id = null, $signal_event_subscription_name = null, $message_event_subscription_name = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null)
    {
        return $this->getExecutionsCountAsyncWithHttpInfo($business_key, $process_definition_id, $process_definition_key, $process_instance_id, $activity_id, $signal_event_subscription_name, $message_event_subscription_name, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExecutionsCountAsyncWithHttpInfo
     *
     * Get Execution Count
     *
     * @param  string $business_key Filter by the business key of the process instances the executions belong to. (optional)
     * @param  string $process_definition_id Filter by the process definition the executions run on. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the executions run on. (optional)
     * @param  string $process_instance_id Filter by the id of the process instance the execution belongs to. (optional)
     * @param  string $activity_id Filter by the id of the activity the execution currently executes. (optional)
     * @param  string $signal_event_subscription_name Select only those executions that expect a signal of the given name. (optional)
     * @param  string $message_event_subscription_name Select only those executions that expect a message of the given name. (optional)
     * @param  bool $active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)
     * @param  string $variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExecutionsCountAsyncWithHttpInfo($business_key = null, $process_definition_id = null, $process_definition_key = null, $process_instance_id = null, $activity_id = null, $signal_event_subscription_name = null, $message_event_subscription_name = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null)
    {
        $returnType = '\OpenAPI\Client\Model\CountResultDto';
        $request = $this->getExecutionsCountRequest($business_key, $process_definition_id, $process_definition_key, $process_instance_id, $activity_id, $signal_event_subscription_name, $message_event_subscription_name, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExecutionsCount'
     *
     * @param  string $business_key Filter by the business key of the process instances the executions belong to. (optional)
     * @param  string $process_definition_id Filter by the process definition the executions run on. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the executions run on. (optional)
     * @param  string $process_instance_id Filter by the id of the process instance the execution belongs to. (optional)
     * @param  string $activity_id Filter by the id of the activity the execution currently executes. (optional)
     * @param  string $signal_event_subscription_name Select only those executions that expect a signal of the given name. (optional)
     * @param  string $message_event_subscription_name Select only those executions that expect a message of the given name. (optional)
     * @param  bool $active Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)
     * @param  string $variables Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getExecutionsCountRequest($business_key = null, $process_definition_id = null, $process_definition_key = null, $process_instance_id = null, $activity_id = null, $signal_event_subscription_name = null, $message_event_subscription_name = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null)
    {

        $resourcePath = '/execution/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($business_key !== null) {
            if('form' === 'form' && is_array($business_key)) {
                foreach($business_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['businessKey'] = $business_key;
            }
        }
        // query params
        if ($process_definition_id !== null) {
            if('form' === 'form' && is_array($process_definition_id)) {
                foreach($process_definition_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionId'] = $process_definition_id;
            }
        }
        // query params
        if ($process_definition_key !== null) {
            if('form' === 'form' && is_array($process_definition_key)) {
                foreach($process_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionKey'] = $process_definition_key;
            }
        }
        // query params
        if ($process_instance_id !== null) {
            if('form' === 'form' && is_array($process_instance_id)) {
                foreach($process_instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceId'] = $process_instance_id;
            }
        }
        // query params
        if ($activity_id !== null) {
            if('form' === 'form' && is_array($activity_id)) {
                foreach($activity_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['activityId'] = $activity_id;
            }
        }
        // query params
        if ($signal_event_subscription_name !== null) {
            if('form' === 'form' && is_array($signal_event_subscription_name)) {
                foreach($signal_event_subscription_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['signalEventSubscriptionName'] = $signal_event_subscription_name;
            }
        }
        // query params
        if ($message_event_subscription_name !== null) {
            if('form' === 'form' && is_array($message_event_subscription_name)) {
                foreach($message_event_subscription_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['messageEventSubscriptionName'] = $message_event_subscription_name;
            }
        }
        // query params
        if ($active !== null) {
            if('form' === 'form' && is_array($active)) {
                foreach($active as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['active'] = $active;
            }
        }
        // query params
        if ($suspended !== null) {
            if('form' === 'form' && is_array($suspended)) {
                foreach($suspended as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['suspended'] = $suspended;
            }
        }
        // query params
        if ($incident_id !== null) {
            if('form' === 'form' && is_array($incident_id)) {
                foreach($incident_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['incidentId'] = $incident_id;
            }
        }
        // query params
        if ($incident_type !== null) {
            if('form' === 'form' && is_array($incident_type)) {
                foreach($incident_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['incidentType'] = $incident_type;
            }
        }
        // query params
        if ($incident_message !== null) {
            if('form' === 'form' && is_array($incident_message)) {
                foreach($incident_message as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['incidentMessage'] = $incident_message;
            }
        }
        // query params
        if ($incident_message_like !== null) {
            if('form' === 'form' && is_array($incident_message_like)) {
                foreach($incident_message_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['incidentMessageLike'] = $incident_message_like;
            }
        }
        // query params
        if ($tenant_id_in !== null) {
            if('form' === 'form' && is_array($tenant_id_in)) {
                foreach($tenant_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tenantIdIn'] = $tenant_id_in;
            }
        }
        // query params
        if ($variables !== null) {
            if('form' === 'form' && is_array($variables)) {
                foreach($variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variables'] = $variables;
            }
        }
        // query params
        if ($process_variables !== null) {
            if('form' === 'form' && is_array($process_variables)) {
                foreach($process_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processVariables'] = $process_variables;
            }
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_names_ignore_case)) {
                foreach($variable_names_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableNamesIgnoreCase'] = $variable_names_ignore_case;
            }
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_values_ignore_case)) {
                foreach($variable_values_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableValuesIgnoreCase'] = $variable_values_ignore_case;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLocalExecutionVariable
     *
     * Get Local Execution Variable
     *
     * @param  string $id The id of the execution to retrieve the variable from. (required)
     * @param  string $var_name The name of the variable to get. (required)
     * @param  bool $deserialize_value Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VariableValueDto|\OpenAPI\Client\Model\ExceptionDto
     */
    public function getLocalExecutionVariable($id, $var_name, $deserialize_value = null)
    {
        list($response) = $this->getLocalExecutionVariableWithHttpInfo($id, $var_name, $deserialize_value);
        return $response;
    }

    /**
     * Operation getLocalExecutionVariableWithHttpInfo
     *
     * Get Local Execution Variable
     *
     * @param  string $id The id of the execution to retrieve the variable from. (required)
     * @param  string $var_name The name of the variable to get. (required)
     * @param  bool $deserialize_value Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VariableValueDto|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLocalExecutionVariableWithHttpInfo($id, $var_name, $deserialize_value = null)
    {
        $request = $this->getLocalExecutionVariableRequest($id, $var_name, $deserialize_value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VariableValueDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VariableValueDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VariableValueDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VariableValueDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLocalExecutionVariableAsync
     *
     * Get Local Execution Variable
     *
     * @param  string $id The id of the execution to retrieve the variable from. (required)
     * @param  string $var_name The name of the variable to get. (required)
     * @param  bool $deserialize_value Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocalExecutionVariableAsync($id, $var_name, $deserialize_value = null)
    {
        return $this->getLocalExecutionVariableAsyncWithHttpInfo($id, $var_name, $deserialize_value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLocalExecutionVariableAsyncWithHttpInfo
     *
     * Get Local Execution Variable
     *
     * @param  string $id The id of the execution to retrieve the variable from. (required)
     * @param  string $var_name The name of the variable to get. (required)
     * @param  bool $deserialize_value Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocalExecutionVariableAsyncWithHttpInfo($id, $var_name, $deserialize_value = null)
    {
        $returnType = '\OpenAPI\Client\Model\VariableValueDto';
        $request = $this->getLocalExecutionVariableRequest($id, $var_name, $deserialize_value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLocalExecutionVariable'
     *
     * @param  string $id The id of the execution to retrieve the variable from. (required)
     * @param  string $var_name The name of the variable to get. (required)
     * @param  bool $deserialize_value Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLocalExecutionVariableRequest($id, $var_name, $deserialize_value = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getLocalExecutionVariable'
            );
        }
        // verify the required parameter 'var_name' is set
        if ($var_name === null || (is_array($var_name) && count($var_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $var_name when calling getLocalExecutionVariable'
            );
        }

        $resourcePath = '/execution/{id}/localVariables/{varName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($deserialize_value !== null) {
            if('form' === 'form' && is_array($deserialize_value)) {
                foreach($deserialize_value as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['deserializeValue'] = $deserialize_value;
            }
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($var_name !== null) {
            $resourcePath = str_replace(
                '{' . 'varName' . '}',
                ObjectSerializer::toPathValue($var_name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLocalExecutionVariableBinary
     *
     * Get Local Execution Variable (Binary)
     *
     * @param  string $id The id of the execution to retrieve the variable from. (required)
     * @param  string $var_name The name of the variable to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ExceptionDto|\OpenAPI\Client\Model\ExceptionDto
     */
    public function getLocalExecutionVariableBinary($id, $var_name)
    {
        list($response) = $this->getLocalExecutionVariableBinaryWithHttpInfo($id, $var_name);
        return $response;
    }

    /**
     * Operation getLocalExecutionVariableBinaryWithHttpInfo
     *
     * Get Local Execution Variable (Binary)
     *
     * @param  string $id The id of the execution to retrieve the variable from. (required)
     * @param  string $var_name The name of the variable to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ExceptionDto|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLocalExecutionVariableBinaryWithHttpInfo($id, $var_name)
    {
        $request = $this->getLocalExecutionVariableBinaryRequest($id, $var_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLocalExecutionVariableBinaryAsync
     *
     * Get Local Execution Variable (Binary)
     *
     * @param  string $id The id of the execution to retrieve the variable from. (required)
     * @param  string $var_name The name of the variable to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocalExecutionVariableBinaryAsync($id, $var_name)
    {
        return $this->getLocalExecutionVariableBinaryAsyncWithHttpInfo($id, $var_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLocalExecutionVariableBinaryAsyncWithHttpInfo
     *
     * Get Local Execution Variable (Binary)
     *
     * @param  string $id The id of the execution to retrieve the variable from. (required)
     * @param  string $var_name The name of the variable to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocalExecutionVariableBinaryAsyncWithHttpInfo($id, $var_name)
    {
        $returnType = '\SplFileObject';
        $request = $this->getLocalExecutionVariableBinaryRequest($id, $var_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLocalExecutionVariableBinary'
     *
     * @param  string $id The id of the execution to retrieve the variable from. (required)
     * @param  string $var_name The name of the variable to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLocalExecutionVariableBinaryRequest($id, $var_name)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getLocalExecutionVariableBinary'
            );
        }
        // verify the required parameter 'var_name' is set
        if ($var_name === null || (is_array($var_name) && count($var_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $var_name when calling getLocalExecutionVariableBinary'
            );
        }

        $resourcePath = '/execution/{id}/localVariables/{varName}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($var_name !== null) {
            $resourcePath = str_replace(
                '{' . 'varName' . '}',
                ObjectSerializer::toPathValue($var_name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream', 'text/plain', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream', 'text/plain', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLocalExecutionVariables
     *
     * Get Local Execution Variables
     *
     * @param  string $id The id of the execution to retrieve the variables from. (required)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,\OpenAPI\Client\Model\VariableValueDto>|\OpenAPI\Client\Model\ExceptionDto
     */
    public function getLocalExecutionVariables($id, $deserialize_values = null)
    {
        list($response) = $this->getLocalExecutionVariablesWithHttpInfo($id, $deserialize_values);
        return $response;
    }

    /**
     * Operation getLocalExecutionVariablesWithHttpInfo
     *
     * Get Local Execution Variables
     *
     * @param  string $id The id of the execution to retrieve the variables from. (required)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,\OpenAPI\Client\Model\VariableValueDto>|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLocalExecutionVariablesWithHttpInfo($id, $deserialize_values = null)
    {
        $request = $this->getLocalExecutionVariablesRequest($id, $deserialize_values);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,\OpenAPI\Client\Model\VariableValueDto>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,\OpenAPI\Client\Model\VariableValueDto>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,\OpenAPI\Client\Model\VariableValueDto>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,\OpenAPI\Client\Model\VariableValueDto>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLocalExecutionVariablesAsync
     *
     * Get Local Execution Variables
     *
     * @param  string $id The id of the execution to retrieve the variables from. (required)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocalExecutionVariablesAsync($id, $deserialize_values = null)
    {
        return $this->getLocalExecutionVariablesAsyncWithHttpInfo($id, $deserialize_values)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLocalExecutionVariablesAsyncWithHttpInfo
     *
     * Get Local Execution Variables
     *
     * @param  string $id The id of the execution to retrieve the variables from. (required)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocalExecutionVariablesAsyncWithHttpInfo($id, $deserialize_values = null)
    {
        $returnType = 'array<string,\OpenAPI\Client\Model\VariableValueDto>';
        $request = $this->getLocalExecutionVariablesRequest($id, $deserialize_values);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLocalExecutionVariables'
     *
     * @param  string $id The id of the execution to retrieve the variables from. (required)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLocalExecutionVariablesRequest($id, $deserialize_values = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getLocalExecutionVariables'
            );
        }

        $resourcePath = '/execution/{id}/localVariables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($deserialize_values !== null) {
            if('form' === 'form' && is_array($deserialize_values)) {
                foreach($deserialize_values as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['deserializeValues'] = $deserialize_values;
            }
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessageEventSubscription
     *
     * Get Message Event Subscription
     *
     * @param  string $id The id of the execution that holds the subscription. (required)
     * @param  string $message_name The name of the message that the subscription corresponds to. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EventSubscriptionDto|\OpenAPI\Client\Model\ExceptionDto
     */
    public function getMessageEventSubscription($id, $message_name)
    {
        list($response) = $this->getMessageEventSubscriptionWithHttpInfo($id, $message_name);
        return $response;
    }

    /**
     * Operation getMessageEventSubscriptionWithHttpInfo
     *
     * Get Message Event Subscription
     *
     * @param  string $id The id of the execution that holds the subscription. (required)
     * @param  string $message_name The name of the message that the subscription corresponds to. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EventSubscriptionDto|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessageEventSubscriptionWithHttpInfo($id, $message_name)
    {
        $request = $this->getMessageEventSubscriptionRequest($id, $message_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EventSubscriptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EventSubscriptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\EventSubscriptionDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EventSubscriptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMessageEventSubscriptionAsync
     *
     * Get Message Event Subscription
     *
     * @param  string $id The id of the execution that holds the subscription. (required)
     * @param  string $message_name The name of the message that the subscription corresponds to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageEventSubscriptionAsync($id, $message_name)
    {
        return $this->getMessageEventSubscriptionAsyncWithHttpInfo($id, $message_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessageEventSubscriptionAsyncWithHttpInfo
     *
     * Get Message Event Subscription
     *
     * @param  string $id The id of the execution that holds the subscription. (required)
     * @param  string $message_name The name of the message that the subscription corresponds to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageEventSubscriptionAsyncWithHttpInfo($id, $message_name)
    {
        $returnType = '\OpenAPI\Client\Model\EventSubscriptionDto';
        $request = $this->getMessageEventSubscriptionRequest($id, $message_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessageEventSubscription'
     *
     * @param  string $id The id of the execution that holds the subscription. (required)
     * @param  string $message_name The name of the message that the subscription corresponds to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessageEventSubscriptionRequest($id, $message_name)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getMessageEventSubscription'
            );
        }
        // verify the required parameter 'message_name' is set
        if ($message_name === null || (is_array($message_name) && count($message_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_name when calling getMessageEventSubscription'
            );
        }

        $resourcePath = '/execution/{id}/messageSubscriptions/{messageName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($message_name !== null) {
            $resourcePath = str_replace(
                '{' . 'messageName' . '}',
                ObjectSerializer::toPathValue($message_name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modifyLocalExecutionVariables
     *
     * Update/Delete Local Execution Variables
     *
     * @param  string $id The id of the execution to set variables for. (required)
     * @param  \OpenAPI\Client\Model\PatchVariablesDto $patch_variables_dto patch_variables_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function modifyLocalExecutionVariables($id, $patch_variables_dto = null)
    {
        $this->modifyLocalExecutionVariablesWithHttpInfo($id, $patch_variables_dto);
    }

    /**
     * Operation modifyLocalExecutionVariablesWithHttpInfo
     *
     * Update/Delete Local Execution Variables
     *
     * @param  string $id The id of the execution to set variables for. (required)
     * @param  \OpenAPI\Client\Model\PatchVariablesDto $patch_variables_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function modifyLocalExecutionVariablesWithHttpInfo($id, $patch_variables_dto = null)
    {
        $request = $this->modifyLocalExecutionVariablesRequest($id, $patch_variables_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modifyLocalExecutionVariablesAsync
     *
     * Update/Delete Local Execution Variables
     *
     * @param  string $id The id of the execution to set variables for. (required)
     * @param  \OpenAPI\Client\Model\PatchVariablesDto $patch_variables_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyLocalExecutionVariablesAsync($id, $patch_variables_dto = null)
    {
        return $this->modifyLocalExecutionVariablesAsyncWithHttpInfo($id, $patch_variables_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modifyLocalExecutionVariablesAsyncWithHttpInfo
     *
     * Update/Delete Local Execution Variables
     *
     * @param  string $id The id of the execution to set variables for. (required)
     * @param  \OpenAPI\Client\Model\PatchVariablesDto $patch_variables_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyLocalExecutionVariablesAsyncWithHttpInfo($id, $patch_variables_dto = null)
    {
        $returnType = '';
        $request = $this->modifyLocalExecutionVariablesRequest($id, $patch_variables_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modifyLocalExecutionVariables'
     *
     * @param  string $id The id of the execution to set variables for. (required)
     * @param  \OpenAPI\Client\Model\PatchVariablesDto $patch_variables_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modifyLocalExecutionVariablesRequest($id, $patch_variables_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modifyLocalExecutionVariables'
            );
        }

        $resourcePath = '/execution/{id}/localVariables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($patch_variables_dto)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($patch_variables_dto));
            } else {
                $httpBody = $patch_variables_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putLocalExecutionVariable
     *
     * Put Local Execution Variable
     *
     * @param  string $id The id of the execution to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \OpenAPI\Client\Model\VariableValueDto $variable_value_dto variable_value_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putLocalExecutionVariable($id, $var_name, $variable_value_dto = null)
    {
        $this->putLocalExecutionVariableWithHttpInfo($id, $var_name, $variable_value_dto);
    }

    /**
     * Operation putLocalExecutionVariableWithHttpInfo
     *
     * Put Local Execution Variable
     *
     * @param  string $id The id of the execution to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \OpenAPI\Client\Model\VariableValueDto $variable_value_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putLocalExecutionVariableWithHttpInfo($id, $var_name, $variable_value_dto = null)
    {
        $request = $this->putLocalExecutionVariableRequest($id, $var_name, $variable_value_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putLocalExecutionVariableAsync
     *
     * Put Local Execution Variable
     *
     * @param  string $id The id of the execution to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \OpenAPI\Client\Model\VariableValueDto $variable_value_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLocalExecutionVariableAsync($id, $var_name, $variable_value_dto = null)
    {
        return $this->putLocalExecutionVariableAsyncWithHttpInfo($id, $var_name, $variable_value_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putLocalExecutionVariableAsyncWithHttpInfo
     *
     * Put Local Execution Variable
     *
     * @param  string $id The id of the execution to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \OpenAPI\Client\Model\VariableValueDto $variable_value_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLocalExecutionVariableAsyncWithHttpInfo($id, $var_name, $variable_value_dto = null)
    {
        $returnType = '';
        $request = $this->putLocalExecutionVariableRequest($id, $var_name, $variable_value_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putLocalExecutionVariable'
     *
     * @param  string $id The id of the execution to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \OpenAPI\Client\Model\VariableValueDto $variable_value_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putLocalExecutionVariableRequest($id, $var_name, $variable_value_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putLocalExecutionVariable'
            );
        }
        // verify the required parameter 'var_name' is set
        if ($var_name === null || (is_array($var_name) && count($var_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $var_name when calling putLocalExecutionVariable'
            );
        }

        $resourcePath = '/execution/{id}/localVariables/{varName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($var_name !== null) {
            $resourcePath = str_replace(
                '{' . 'varName' . '}',
                ObjectSerializer::toPathValue($var_name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($variable_value_dto)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($variable_value_dto));
            } else {
                $httpBody = $variable_value_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryExecutions
     *
     * Get Executions (POST)
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \OpenAPI\Client\Model\ExecutionQueryDto $execution_query_dto execution_query_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExecutionDto[]|\OpenAPI\Client\Model\ExceptionDto
     */
    public function queryExecutions($first_result = null, $max_results = null, $execution_query_dto = null)
    {
        list($response) = $this->queryExecutionsWithHttpInfo($first_result, $max_results, $execution_query_dto);
        return $response;
    }

    /**
     * Operation queryExecutionsWithHttpInfo
     *
     * Get Executions (POST)
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \OpenAPI\Client\Model\ExecutionQueryDto $execution_query_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExecutionDto[]|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryExecutionsWithHttpInfo($first_result = null, $max_results = null, $execution_query_dto = null)
    {
        $request = $this->queryExecutionsRequest($first_result, $max_results, $execution_query_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ExecutionDto[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExecutionDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ExecutionDto[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExecutionDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryExecutionsAsync
     *
     * Get Executions (POST)
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \OpenAPI\Client\Model\ExecutionQueryDto $execution_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryExecutionsAsync($first_result = null, $max_results = null, $execution_query_dto = null)
    {
        return $this->queryExecutionsAsyncWithHttpInfo($first_result, $max_results, $execution_query_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryExecutionsAsyncWithHttpInfo
     *
     * Get Executions (POST)
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \OpenAPI\Client\Model\ExecutionQueryDto $execution_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryExecutionsAsyncWithHttpInfo($first_result = null, $max_results = null, $execution_query_dto = null)
    {
        $returnType = '\OpenAPI\Client\Model\ExecutionDto[]';
        $request = $this->queryExecutionsRequest($first_result, $max_results, $execution_query_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryExecutions'
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \OpenAPI\Client\Model\ExecutionQueryDto $execution_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queryExecutionsRequest($first_result = null, $max_results = null, $execution_query_dto = null)
    {

        $resourcePath = '/execution';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($first_result !== null) {
            if('form' === 'form' && is_array($first_result)) {
                foreach($first_result as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['firstResult'] = $first_result;
            }
        }
        // query params
        if ($max_results !== null) {
            if('form' === 'form' && is_array($max_results)) {
                foreach($max_results as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxResults'] = $max_results;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($execution_query_dto)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($execution_query_dto));
            } else {
                $httpBody = $execution_query_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryExecutionsCount
     *
     * Get Execution Count (POST)
     *
     * @param  \OpenAPI\Client\Model\ExecutionQueryDto $execution_query_dto execution_query_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CountResultDto|\OpenAPI\Client\Model\ExceptionDto
     */
    public function queryExecutionsCount($execution_query_dto = null)
    {
        list($response) = $this->queryExecutionsCountWithHttpInfo($execution_query_dto);
        return $response;
    }

    /**
     * Operation queryExecutionsCountWithHttpInfo
     *
     * Get Execution Count (POST)
     *
     * @param  \OpenAPI\Client\Model\ExecutionQueryDto $execution_query_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CountResultDto|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryExecutionsCountWithHttpInfo($execution_query_dto = null)
    {
        $request = $this->queryExecutionsCountRequest($execution_query_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CountResultDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CountResultDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CountResultDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryExecutionsCountAsync
     *
     * Get Execution Count (POST)
     *
     * @param  \OpenAPI\Client\Model\ExecutionQueryDto $execution_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryExecutionsCountAsync($execution_query_dto = null)
    {
        return $this->queryExecutionsCountAsyncWithHttpInfo($execution_query_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryExecutionsCountAsyncWithHttpInfo
     *
     * Get Execution Count (POST)
     *
     * @param  \OpenAPI\Client\Model\ExecutionQueryDto $execution_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryExecutionsCountAsyncWithHttpInfo($execution_query_dto = null)
    {
        $returnType = '\OpenAPI\Client\Model\CountResultDto';
        $request = $this->queryExecutionsCountRequest($execution_query_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryExecutionsCount'
     *
     * @param  \OpenAPI\Client\Model\ExecutionQueryDto $execution_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queryExecutionsCountRequest($execution_query_dto = null)
    {

        $resourcePath = '/execution/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($execution_query_dto)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($execution_query_dto));
            } else {
                $httpBody = $execution_query_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setLocalExecutionVariableBinary
     *
     * Post Local Execution Variable (Binary)
     *
     * @param  string $id The id of the execution to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \SplFileObject $data The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)
     * @param  string $value_type The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setLocalExecutionVariableBinary($id, $var_name, $data = null, $value_type = null)
    {
        $this->setLocalExecutionVariableBinaryWithHttpInfo($id, $var_name, $data, $value_type);
    }

    /**
     * Operation setLocalExecutionVariableBinaryWithHttpInfo
     *
     * Post Local Execution Variable (Binary)
     *
     * @param  string $id The id of the execution to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \SplFileObject $data The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)
     * @param  string $value_type The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setLocalExecutionVariableBinaryWithHttpInfo($id, $var_name, $data = null, $value_type = null)
    {
        $request = $this->setLocalExecutionVariableBinaryRequest($id, $var_name, $data, $value_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setLocalExecutionVariableBinaryAsync
     *
     * Post Local Execution Variable (Binary)
     *
     * @param  string $id The id of the execution to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \SplFileObject $data The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)
     * @param  string $value_type The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setLocalExecutionVariableBinaryAsync($id, $var_name, $data = null, $value_type = null)
    {
        return $this->setLocalExecutionVariableBinaryAsyncWithHttpInfo($id, $var_name, $data, $value_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setLocalExecutionVariableBinaryAsyncWithHttpInfo
     *
     * Post Local Execution Variable (Binary)
     *
     * @param  string $id The id of the execution to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \SplFileObject $data The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)
     * @param  string $value_type The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setLocalExecutionVariableBinaryAsyncWithHttpInfo($id, $var_name, $data = null, $value_type = null)
    {
        $returnType = '';
        $request = $this->setLocalExecutionVariableBinaryRequest($id, $var_name, $data, $value_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setLocalExecutionVariableBinary'
     *
     * @param  string $id The id of the execution to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \SplFileObject $data The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)
     * @param  string $value_type The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setLocalExecutionVariableBinaryRequest($id, $var_name, $data = null, $value_type = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setLocalExecutionVariableBinary'
            );
        }
        // verify the required parameter 'var_name' is set
        if ($var_name === null || (is_array($var_name) && count($var_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $var_name when calling setLocalExecutionVariableBinary'
            );
        }

        $resourcePath = '/execution/{id}/localVariables/{varName}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($var_name !== null) {
            $resourcePath = str_replace(
                '{' . 'varName' . '}',
                ObjectSerializer::toPathValue($var_name),
                $resourcePath
            );
        }

        // form params
        if ($data !== null) {
            $multipart = true;
            $formParams['data'] = [];
            $paramFiles = is_array($data) ? $data : [$data];
            foreach ($paramFiles as $paramFile) {
                $formParams['data'][] = \GuzzleHttp\Psr7\try_fopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($value_type !== null) {
            $formParams['valueType'] = ObjectSerializer::toFormValue($value_type);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signalExecution
     *
     * Trigger Execution
     *
     * @param  string $id The id of the execution to signal. (required)
     * @param  \OpenAPI\Client\Model\ExecutionTriggerDto $execution_trigger_dto execution_trigger_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function signalExecution($id, $execution_trigger_dto = null)
    {
        $this->signalExecutionWithHttpInfo($id, $execution_trigger_dto);
    }

    /**
     * Operation signalExecutionWithHttpInfo
     *
     * Trigger Execution
     *
     * @param  string $id The id of the execution to signal. (required)
     * @param  \OpenAPI\Client\Model\ExecutionTriggerDto $execution_trigger_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function signalExecutionWithHttpInfo($id, $execution_trigger_dto = null)
    {
        $request = $this->signalExecutionRequest($id, $execution_trigger_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation signalExecutionAsync
     *
     * Trigger Execution
     *
     * @param  string $id The id of the execution to signal. (required)
     * @param  \OpenAPI\Client\Model\ExecutionTriggerDto $execution_trigger_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signalExecutionAsync($id, $execution_trigger_dto = null)
    {
        return $this->signalExecutionAsyncWithHttpInfo($id, $execution_trigger_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signalExecutionAsyncWithHttpInfo
     *
     * Trigger Execution
     *
     * @param  string $id The id of the execution to signal. (required)
     * @param  \OpenAPI\Client\Model\ExecutionTriggerDto $execution_trigger_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signalExecutionAsyncWithHttpInfo($id, $execution_trigger_dto = null)
    {
        $returnType = '';
        $request = $this->signalExecutionRequest($id, $execution_trigger_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signalExecution'
     *
     * @param  string $id The id of the execution to signal. (required)
     * @param  \OpenAPI\Client\Model\ExecutionTriggerDto $execution_trigger_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function signalExecutionRequest($id, $execution_trigger_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling signalExecution'
            );
        }

        $resourcePath = '/execution/{id}/signal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($execution_trigger_dto)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($execution_trigger_dto));
            } else {
                $httpBody = $execution_trigger_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation triggerEvent
     *
     * Trigger Message Event Subscription
     *
     * @param  string $id The id of the execution to submit the message to. (required)
     * @param  string $message_name The name of the message that the addressed subscription corresponds to. (required)
     * @param  \OpenAPI\Client\Model\ExecutionTriggerDto $execution_trigger_dto execution_trigger_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function triggerEvent($id, $message_name, $execution_trigger_dto = null)
    {
        $this->triggerEventWithHttpInfo($id, $message_name, $execution_trigger_dto);
    }

    /**
     * Operation triggerEventWithHttpInfo
     *
     * Trigger Message Event Subscription
     *
     * @param  string $id The id of the execution to submit the message to. (required)
     * @param  string $message_name The name of the message that the addressed subscription corresponds to. (required)
     * @param  \OpenAPI\Client\Model\ExecutionTriggerDto $execution_trigger_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function triggerEventWithHttpInfo($id, $message_name, $execution_trigger_dto = null)
    {
        $request = $this->triggerEventRequest($id, $message_name, $execution_trigger_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation triggerEventAsync
     *
     * Trigger Message Event Subscription
     *
     * @param  string $id The id of the execution to submit the message to. (required)
     * @param  string $message_name The name of the message that the addressed subscription corresponds to. (required)
     * @param  \OpenAPI\Client\Model\ExecutionTriggerDto $execution_trigger_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function triggerEventAsync($id, $message_name, $execution_trigger_dto = null)
    {
        return $this->triggerEventAsyncWithHttpInfo($id, $message_name, $execution_trigger_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation triggerEventAsyncWithHttpInfo
     *
     * Trigger Message Event Subscription
     *
     * @param  string $id The id of the execution to submit the message to. (required)
     * @param  string $message_name The name of the message that the addressed subscription corresponds to. (required)
     * @param  \OpenAPI\Client\Model\ExecutionTriggerDto $execution_trigger_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function triggerEventAsyncWithHttpInfo($id, $message_name, $execution_trigger_dto = null)
    {
        $returnType = '';
        $request = $this->triggerEventRequest($id, $message_name, $execution_trigger_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'triggerEvent'
     *
     * @param  string $id The id of the execution to submit the message to. (required)
     * @param  string $message_name The name of the message that the addressed subscription corresponds to. (required)
     * @param  \OpenAPI\Client\Model\ExecutionTriggerDto $execution_trigger_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function triggerEventRequest($id, $message_name, $execution_trigger_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling triggerEvent'
            );
        }
        // verify the required parameter 'message_name' is set
        if ($message_name === null || (is_array($message_name) && count($message_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_name when calling triggerEvent'
            );
        }

        $resourcePath = '/execution/{id}/messageSubscriptions/{messageName}/trigger';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($message_name !== null) {
            $resourcePath = str_replace(
                '{' . 'messageName' . '}',
                ObjectSerializer::toPathValue($message_name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($execution_trigger_dto)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($execution_trigger_dto));
            } else {
                $httpBody = $execution_trigger_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
