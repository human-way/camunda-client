<?php
/**
 * HistoricTaskInstanceApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.16.0-alpha2
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.2.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * HistoricTaskInstanceApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class HistoricTaskInstanceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getHistoricTaskInstanceReport
     *
     * Get Task Report (Historic)
     *
     * @param  string $report_type **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;. (optional)
     * @param  string $period_unit When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;. (optional)
     * @param  \DateTime $completed_before Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $completed_after Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $group_by When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HistoricTaskInstanceReportResultDto[]|\OpenAPI\Client\Model\ExceptionDto
     */
    public function getHistoricTaskInstanceReport($report_type = null, $period_unit = null, $completed_before = null, $completed_after = null, $group_by = null)
    {
        list($response) = $this->getHistoricTaskInstanceReportWithHttpInfo($report_type, $period_unit, $completed_before, $completed_after, $group_by);
        return $response;
    }

    /**
     * Operation getHistoricTaskInstanceReportWithHttpInfo
     *
     * Get Task Report (Historic)
     *
     * @param  string $report_type **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;. (optional)
     * @param  string $period_unit When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;. (optional)
     * @param  \DateTime $completed_before Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $completed_after Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $group_by When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HistoricTaskInstanceReportResultDto[]|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricTaskInstanceReportWithHttpInfo($report_type = null, $period_unit = null, $completed_before = null, $completed_after = null, $group_by = null)
    {
        $request = $this->getHistoricTaskInstanceReportRequest($report_type, $period_unit, $completed_before, $completed_after, $group_by);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\HistoricTaskInstanceReportResultDto[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\HistoricTaskInstanceReportResultDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\HistoricTaskInstanceReportResultDto[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HistoricTaskInstanceReportResultDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricTaskInstanceReportAsync
     *
     * Get Task Report (Historic)
     *
     * @param  string $report_type **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;. (optional)
     * @param  string $period_unit When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;. (optional)
     * @param  \DateTime $completed_before Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $completed_after Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $group_by When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstanceReportAsync($report_type = null, $period_unit = null, $completed_before = null, $completed_after = null, $group_by = null)
    {
        return $this->getHistoricTaskInstanceReportAsyncWithHttpInfo($report_type, $period_unit, $completed_before, $completed_after, $group_by)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricTaskInstanceReportAsyncWithHttpInfo
     *
     * Get Task Report (Historic)
     *
     * @param  string $report_type **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;. (optional)
     * @param  string $period_unit When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;. (optional)
     * @param  \DateTime $completed_before Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $completed_after Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $group_by When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstanceReportAsyncWithHttpInfo($report_type = null, $period_unit = null, $completed_before = null, $completed_after = null, $group_by = null)
    {
        $returnType = '\OpenAPI\Client\Model\HistoricTaskInstanceReportResultDto[]';
        $request = $this->getHistoricTaskInstanceReportRequest($report_type, $period_unit, $completed_before, $completed_after, $group_by);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricTaskInstanceReport'
     *
     * @param  string $report_type **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;. (optional)
     * @param  string $period_unit When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;. (optional)
     * @param  \DateTime $completed_before Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $completed_after Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $group_by When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getHistoricTaskInstanceReportRequest($report_type = null, $period_unit = null, $completed_before = null, $completed_after = null, $group_by = null)
    {

        $resourcePath = '/history/task/report';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($report_type !== null) {
            if('form' === 'form' && is_array($report_type)) {
                foreach($report_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['reportType'] = $report_type;
            }
        }
        // query params
        if ($period_unit !== null) {
            if('form' === 'form' && is_array($period_unit)) {
                foreach($period_unit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['periodUnit'] = $period_unit;
            }
        }
        // query params
        if ($completed_before !== null) {
            if('form' === 'form' && is_array($completed_before)) {
                foreach($completed_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['completedBefore'] = $completed_before;
            }
        }
        // query params
        if ($completed_after !== null) {
            if('form' === 'form' && is_array($completed_after)) {
                foreach($completed_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['completedAfter'] = $completed_after;
            }
        }
        // query params
        if ($group_by !== null) {
            if('form' === 'form' && is_array($group_by)) {
                foreach($group_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['groupBy'] = $group_by;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricTaskInstances
     *
     * Get Tasks (Historic)
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HistoricTaskInstanceDto[]|\OpenAPI\Client\Model\ExceptionDto
     */
    public function getHistoricTaskInstances($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        list($response) = $this->getHistoricTaskInstancesWithHttpInfo($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups, $sort_by, $sort_order, $first_result, $max_results);
        return $response;
    }

    /**
     * Operation getHistoricTaskInstancesWithHttpInfo
     *
     * Get Tasks (Historic)
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HistoricTaskInstanceDto[]|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricTaskInstancesWithHttpInfo($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $request = $this->getHistoricTaskInstancesRequest($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups, $sort_by, $sort_order, $first_result, $max_results);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\HistoricTaskInstanceDto[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\HistoricTaskInstanceDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\HistoricTaskInstanceDto[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HistoricTaskInstanceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricTaskInstancesAsync
     *
     * Get Tasks (Historic)
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstancesAsync($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        return $this->getHistoricTaskInstancesAsyncWithHttpInfo($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups, $sort_by, $sort_order, $first_result, $max_results)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricTaskInstancesAsyncWithHttpInfo
     *
     * Get Tasks (Historic)
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstancesAsyncWithHttpInfo($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $returnType = '\OpenAPI\Client\Model\HistoricTaskInstanceDto[]';
        $request = $this->getHistoricTaskInstancesRequest($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups, $sort_by, $sort_order, $first_result, $max_results);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricTaskInstances'
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getHistoricTaskInstancesRequest($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {

        $resourcePath = '/history/task';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_id !== null) {
            if('form' === 'form' && is_array($task_id)) {
                foreach($task_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskId'] = $task_id;
            }
        }
        // query params
        if ($task_parent_task_id !== null) {
            if('form' === 'form' && is_array($task_parent_task_id)) {
                foreach($task_parent_task_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskParentTaskId'] = $task_parent_task_id;
            }
        }
        // query params
        if ($process_instance_id !== null) {
            if('form' === 'form' && is_array($process_instance_id)) {
                foreach($process_instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceId'] = $process_instance_id;
            }
        }
        // query params
        if ($process_instance_business_key !== null) {
            if('form' === 'form' && is_array($process_instance_business_key)) {
                foreach($process_instance_business_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKey'] = $process_instance_business_key;
            }
        }
        // query params
        if ($process_instance_business_key_in !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_in)) {
                foreach($process_instance_business_key_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyIn'] = $process_instance_business_key_in;
            }
        }
        // query params
        if ($process_instance_business_key_like !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_like)) {
                foreach($process_instance_business_key_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyLike'] = $process_instance_business_key_like;
            }
        }
        // query params
        if ($execution_id !== null) {
            if('form' === 'form' && is_array($execution_id)) {
                foreach($execution_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['executionId'] = $execution_id;
            }
        }
        // query params
        if ($process_definition_id !== null) {
            if('form' === 'form' && is_array($process_definition_id)) {
                foreach($process_definition_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionId'] = $process_definition_id;
            }
        }
        // query params
        if ($process_definition_key !== null) {
            if('form' === 'form' && is_array($process_definition_key)) {
                foreach($process_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionKey'] = $process_definition_key;
            }
        }
        // query params
        if ($process_definition_name !== null) {
            if('form' === 'form' && is_array($process_definition_name)) {
                foreach($process_definition_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionName'] = $process_definition_name;
            }
        }
        // query params
        if ($case_instance_id !== null) {
            if('form' === 'form' && is_array($case_instance_id)) {
                foreach($case_instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseInstanceId'] = $case_instance_id;
            }
        }
        // query params
        if ($case_execution_id !== null) {
            if('form' === 'form' && is_array($case_execution_id)) {
                foreach($case_execution_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseExecutionId'] = $case_execution_id;
            }
        }
        // query params
        if ($case_definition_id !== null) {
            if('form' === 'form' && is_array($case_definition_id)) {
                foreach($case_definition_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionId'] = $case_definition_id;
            }
        }
        // query params
        if ($case_definition_key !== null) {
            if('form' === 'form' && is_array($case_definition_key)) {
                foreach($case_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionKey'] = $case_definition_key;
            }
        }
        // query params
        if ($case_definition_name !== null) {
            if('form' === 'form' && is_array($case_definition_name)) {
                foreach($case_definition_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionName'] = $case_definition_name;
            }
        }
        // query params
        if ($activity_instance_id_in !== null) {
            if('form' === 'form' && is_array($activity_instance_id_in)) {
                foreach($activity_instance_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['activityInstanceIdIn'] = $activity_instance_id_in;
            }
        }
        // query params
        if ($task_name !== null) {
            if('form' === 'form' && is_array($task_name)) {
                foreach($task_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskName'] = $task_name;
            }
        }
        // query params
        if ($task_name_like !== null) {
            if('form' === 'form' && is_array($task_name_like)) {
                foreach($task_name_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskNameLike'] = $task_name_like;
            }
        }
        // query params
        if ($task_description !== null) {
            if('form' === 'form' && is_array($task_description)) {
                foreach($task_description as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDescription'] = $task_description;
            }
        }
        // query params
        if ($task_description_like !== null) {
            if('form' === 'form' && is_array($task_description_like)) {
                foreach($task_description_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDescriptionLike'] = $task_description_like;
            }
        }
        // query params
        if ($task_definition_key !== null) {
            if('form' === 'form' && is_array($task_definition_key)) {
                foreach($task_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDefinitionKey'] = $task_definition_key;
            }
        }
        // query params
        if ($task_definition_key_in !== null) {
            if('form' === 'form' && is_array($task_definition_key_in)) {
                foreach($task_definition_key_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDefinitionKeyIn'] = $task_definition_key_in;
            }
        }
        // query params
        if ($task_delete_reason !== null) {
            if('form' === 'form' && is_array($task_delete_reason)) {
                foreach($task_delete_reason as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDeleteReason'] = $task_delete_reason;
            }
        }
        // query params
        if ($task_delete_reason_like !== null) {
            if('form' === 'form' && is_array($task_delete_reason_like)) {
                foreach($task_delete_reason_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDeleteReasonLike'] = $task_delete_reason_like;
            }
        }
        // query params
        if ($task_assignee !== null) {
            if('form' === 'form' && is_array($task_assignee)) {
                foreach($task_assignee as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskAssignee'] = $task_assignee;
            }
        }
        // query params
        if ($task_assignee_like !== null) {
            if('form' === 'form' && is_array($task_assignee_like)) {
                foreach($task_assignee_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskAssigneeLike'] = $task_assignee_like;
            }
        }
        // query params
        if ($task_owner !== null) {
            if('form' === 'form' && is_array($task_owner)) {
                foreach($task_owner as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskOwner'] = $task_owner;
            }
        }
        // query params
        if ($task_owner_like !== null) {
            if('form' === 'form' && is_array($task_owner_like)) {
                foreach($task_owner_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskOwnerLike'] = $task_owner_like;
            }
        }
        // query params
        if ($task_priority !== null) {
            if('form' === 'form' && is_array($task_priority)) {
                foreach($task_priority as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskPriority'] = $task_priority;
            }
        }
        // query params
        if ($assigned !== null) {
            if('form' === 'form' && is_array($assigned)) {
                foreach($assigned as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigned'] = $assigned;
            }
        }
        // query params
        if ($unassigned !== null) {
            if('form' === 'form' && is_array($unassigned)) {
                foreach($unassigned as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['unassigned'] = $unassigned;
            }
        }
        // query params
        if ($finished !== null) {
            if('form' === 'form' && is_array($finished)) {
                foreach($finished as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['finished'] = $finished;
            }
        }
        // query params
        if ($unfinished !== null) {
            if('form' === 'form' && is_array($unfinished)) {
                foreach($unfinished as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['unfinished'] = $unfinished;
            }
        }
        // query params
        if ($process_finished !== null) {
            if('form' === 'form' && is_array($process_finished)) {
                foreach($process_finished as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processFinished'] = $process_finished;
            }
        }
        // query params
        if ($process_unfinished !== null) {
            if('form' === 'form' && is_array($process_unfinished)) {
                foreach($process_unfinished as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processUnfinished'] = $process_unfinished;
            }
        }
        // query params
        if ($task_due_date !== null) {
            if('form' === 'form' && is_array($task_due_date)) {
                foreach($task_due_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDueDate'] = $task_due_date;
            }
        }
        // query params
        if ($task_due_date_before !== null) {
            if('form' === 'form' && is_array($task_due_date_before)) {
                foreach($task_due_date_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDueDateBefore'] = $task_due_date_before;
            }
        }
        // query params
        if ($task_due_date_after !== null) {
            if('form' === 'form' && is_array($task_due_date_after)) {
                foreach($task_due_date_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDueDateAfter'] = $task_due_date_after;
            }
        }
        // query params
        if ($without_task_due_date !== null) {
            if('form' === 'form' && is_array($without_task_due_date)) {
                foreach($without_task_due_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutTaskDueDate'] = $without_task_due_date;
            }
        }
        // query params
        if ($task_follow_up_date !== null) {
            if('form' === 'form' && is_array($task_follow_up_date)) {
                foreach($task_follow_up_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskFollowUpDate'] = $task_follow_up_date;
            }
        }
        // query params
        if ($task_follow_up_date_before !== null) {
            if('form' === 'form' && is_array($task_follow_up_date_before)) {
                foreach($task_follow_up_date_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskFollowUpDateBefore'] = $task_follow_up_date_before;
            }
        }
        // query params
        if ($task_follow_up_date_after !== null) {
            if('form' === 'form' && is_array($task_follow_up_date_after)) {
                foreach($task_follow_up_date_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskFollowUpDateAfter'] = $task_follow_up_date_after;
            }
        }
        // query params
        if ($started_before !== null) {
            if('form' === 'form' && is_array($started_before)) {
                foreach($started_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startedBefore'] = $started_before;
            }
        }
        // query params
        if ($started_after !== null) {
            if('form' === 'form' && is_array($started_after)) {
                foreach($started_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startedAfter'] = $started_after;
            }
        }
        // query params
        if ($finished_before !== null) {
            if('form' === 'form' && is_array($finished_before)) {
                foreach($finished_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['finishedBefore'] = $finished_before;
            }
        }
        // query params
        if ($finished_after !== null) {
            if('form' === 'form' && is_array($finished_after)) {
                foreach($finished_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['finishedAfter'] = $finished_after;
            }
        }
        // query params
        if ($tenant_id_in !== null) {
            if('form' === 'form' && is_array($tenant_id_in)) {
                foreach($tenant_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tenantIdIn'] = $tenant_id_in;
            }
        }
        // query params
        if ($without_tenant_id !== null) {
            if('form' === 'form' && is_array($without_tenant_id)) {
                foreach($without_tenant_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutTenantId'] = $without_tenant_id;
            }
        }
        // query params
        if ($task_variables !== null) {
            if('form' === 'form' && is_array($task_variables)) {
                foreach($task_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskVariables'] = $task_variables;
            }
        }
        // query params
        if ($process_variables !== null) {
            if('form' === 'form' && is_array($process_variables)) {
                foreach($process_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processVariables'] = $process_variables;
            }
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_names_ignore_case)) {
                foreach($variable_names_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableNamesIgnoreCase'] = $variable_names_ignore_case;
            }
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_values_ignore_case)) {
                foreach($variable_values_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableValuesIgnoreCase'] = $variable_values_ignore_case;
            }
        }
        // query params
        if ($task_involved_user !== null) {
            if('form' === 'form' && is_array($task_involved_user)) {
                foreach($task_involved_user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskInvolvedUser'] = $task_involved_user;
            }
        }
        // query params
        if ($task_involved_group !== null) {
            if('form' === 'form' && is_array($task_involved_group)) {
                foreach($task_involved_group as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskInvolvedGroup'] = $task_involved_group;
            }
        }
        // query params
        if ($task_had_candidate_user !== null) {
            if('form' === 'form' && is_array($task_had_candidate_user)) {
                foreach($task_had_candidate_user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskHadCandidateUser'] = $task_had_candidate_user;
            }
        }
        // query params
        if ($task_had_candidate_group !== null) {
            if('form' === 'form' && is_array($task_had_candidate_group)) {
                foreach($task_had_candidate_group as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskHadCandidateGroup'] = $task_had_candidate_group;
            }
        }
        // query params
        if ($with_candidate_groups !== null) {
            if('form' === 'form' && is_array($with_candidate_groups)) {
                foreach($with_candidate_groups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withCandidateGroups'] = $with_candidate_groups;
            }
        }
        // query params
        if ($without_candidate_groups !== null) {
            if('form' === 'form' && is_array($without_candidate_groups)) {
                foreach($without_candidate_groups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutCandidateGroups'] = $without_candidate_groups;
            }
        }
        // query params
        if ($sort_by !== null) {
            if('form' === 'form' && is_array($sort_by)) {
                foreach($sort_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sortBy'] = $sort_by;
            }
        }
        // query params
        if ($sort_order !== null) {
            if('form' === 'form' && is_array($sort_order)) {
                foreach($sort_order as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sortOrder'] = $sort_order;
            }
        }
        // query params
        if ($first_result !== null) {
            if('form' === 'form' && is_array($first_result)) {
                foreach($first_result as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['firstResult'] = $first_result;
            }
        }
        // query params
        if ($max_results !== null) {
            if('form' === 'form' && is_array($max_results)) {
                foreach($max_results as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxResults'] = $max_results;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricTaskInstancesCount
     *
     * Get Task Count
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CountResultDto|\OpenAPI\Client\Model\ExceptionDto
     */
    public function getHistoricTaskInstancesCount($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null)
    {
        list($response) = $this->getHistoricTaskInstancesCountWithHttpInfo($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups);
        return $response;
    }

    /**
     * Operation getHistoricTaskInstancesCountWithHttpInfo
     *
     * Get Task Count
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CountResultDto|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricTaskInstancesCountWithHttpInfo($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null)
    {
        $request = $this->getHistoricTaskInstancesCountRequest($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CountResultDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CountResultDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CountResultDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricTaskInstancesCountAsync
     *
     * Get Task Count
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstancesCountAsync($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null)
    {
        return $this->getHistoricTaskInstancesCountAsyncWithHttpInfo($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricTaskInstancesCountAsyncWithHttpInfo
     *
     * Get Task Count
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstancesCountAsyncWithHttpInfo($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null)
    {
        $returnType = '\OpenAPI\Client\Model\CountResultDto';
        $request = $this->getHistoricTaskInstancesCountRequest($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricTaskInstancesCount'
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getHistoricTaskInstancesCountRequest($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null)
    {

        $resourcePath = '/history/task/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_id !== null) {
            if('form' === 'form' && is_array($task_id)) {
                foreach($task_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskId'] = $task_id;
            }
        }
        // query params
        if ($task_parent_task_id !== null) {
            if('form' === 'form' && is_array($task_parent_task_id)) {
                foreach($task_parent_task_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskParentTaskId'] = $task_parent_task_id;
            }
        }
        // query params
        if ($process_instance_id !== null) {
            if('form' === 'form' && is_array($process_instance_id)) {
                foreach($process_instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceId'] = $process_instance_id;
            }
        }
        // query params
        if ($process_instance_business_key !== null) {
            if('form' === 'form' && is_array($process_instance_business_key)) {
                foreach($process_instance_business_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKey'] = $process_instance_business_key;
            }
        }
        // query params
        if ($process_instance_business_key_in !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_in)) {
                foreach($process_instance_business_key_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyIn'] = $process_instance_business_key_in;
            }
        }
        // query params
        if ($process_instance_business_key_like !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_like)) {
                foreach($process_instance_business_key_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyLike'] = $process_instance_business_key_like;
            }
        }
        // query params
        if ($execution_id !== null) {
            if('form' === 'form' && is_array($execution_id)) {
                foreach($execution_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['executionId'] = $execution_id;
            }
        }
        // query params
        if ($process_definition_id !== null) {
            if('form' === 'form' && is_array($process_definition_id)) {
                foreach($process_definition_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionId'] = $process_definition_id;
            }
        }
        // query params
        if ($process_definition_key !== null) {
            if('form' === 'form' && is_array($process_definition_key)) {
                foreach($process_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionKey'] = $process_definition_key;
            }
        }
        // query params
        if ($process_definition_name !== null) {
            if('form' === 'form' && is_array($process_definition_name)) {
                foreach($process_definition_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionName'] = $process_definition_name;
            }
        }
        // query params
        if ($case_instance_id !== null) {
            if('form' === 'form' && is_array($case_instance_id)) {
                foreach($case_instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseInstanceId'] = $case_instance_id;
            }
        }
        // query params
        if ($case_execution_id !== null) {
            if('form' === 'form' && is_array($case_execution_id)) {
                foreach($case_execution_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseExecutionId'] = $case_execution_id;
            }
        }
        // query params
        if ($case_definition_id !== null) {
            if('form' === 'form' && is_array($case_definition_id)) {
                foreach($case_definition_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionId'] = $case_definition_id;
            }
        }
        // query params
        if ($case_definition_key !== null) {
            if('form' === 'form' && is_array($case_definition_key)) {
                foreach($case_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionKey'] = $case_definition_key;
            }
        }
        // query params
        if ($case_definition_name !== null) {
            if('form' === 'form' && is_array($case_definition_name)) {
                foreach($case_definition_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionName'] = $case_definition_name;
            }
        }
        // query params
        if ($activity_instance_id_in !== null) {
            if('form' === 'form' && is_array($activity_instance_id_in)) {
                foreach($activity_instance_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['activityInstanceIdIn'] = $activity_instance_id_in;
            }
        }
        // query params
        if ($task_name !== null) {
            if('form' === 'form' && is_array($task_name)) {
                foreach($task_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskName'] = $task_name;
            }
        }
        // query params
        if ($task_name_like !== null) {
            if('form' === 'form' && is_array($task_name_like)) {
                foreach($task_name_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskNameLike'] = $task_name_like;
            }
        }
        // query params
        if ($task_description !== null) {
            if('form' === 'form' && is_array($task_description)) {
                foreach($task_description as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDescription'] = $task_description;
            }
        }
        // query params
        if ($task_description_like !== null) {
            if('form' === 'form' && is_array($task_description_like)) {
                foreach($task_description_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDescriptionLike'] = $task_description_like;
            }
        }
        // query params
        if ($task_definition_key !== null) {
            if('form' === 'form' && is_array($task_definition_key)) {
                foreach($task_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDefinitionKey'] = $task_definition_key;
            }
        }
        // query params
        if ($task_definition_key_in !== null) {
            if('form' === 'form' && is_array($task_definition_key_in)) {
                foreach($task_definition_key_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDefinitionKeyIn'] = $task_definition_key_in;
            }
        }
        // query params
        if ($task_delete_reason !== null) {
            if('form' === 'form' && is_array($task_delete_reason)) {
                foreach($task_delete_reason as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDeleteReason'] = $task_delete_reason;
            }
        }
        // query params
        if ($task_delete_reason_like !== null) {
            if('form' === 'form' && is_array($task_delete_reason_like)) {
                foreach($task_delete_reason_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDeleteReasonLike'] = $task_delete_reason_like;
            }
        }
        // query params
        if ($task_assignee !== null) {
            if('form' === 'form' && is_array($task_assignee)) {
                foreach($task_assignee as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskAssignee'] = $task_assignee;
            }
        }
        // query params
        if ($task_assignee_like !== null) {
            if('form' === 'form' && is_array($task_assignee_like)) {
                foreach($task_assignee_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskAssigneeLike'] = $task_assignee_like;
            }
        }
        // query params
        if ($task_owner !== null) {
            if('form' === 'form' && is_array($task_owner)) {
                foreach($task_owner as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskOwner'] = $task_owner;
            }
        }
        // query params
        if ($task_owner_like !== null) {
            if('form' === 'form' && is_array($task_owner_like)) {
                foreach($task_owner_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskOwnerLike'] = $task_owner_like;
            }
        }
        // query params
        if ($task_priority !== null) {
            if('form' === 'form' && is_array($task_priority)) {
                foreach($task_priority as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskPriority'] = $task_priority;
            }
        }
        // query params
        if ($assigned !== null) {
            if('form' === 'form' && is_array($assigned)) {
                foreach($assigned as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigned'] = $assigned;
            }
        }
        // query params
        if ($unassigned !== null) {
            if('form' === 'form' && is_array($unassigned)) {
                foreach($unassigned as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['unassigned'] = $unassigned;
            }
        }
        // query params
        if ($finished !== null) {
            if('form' === 'form' && is_array($finished)) {
                foreach($finished as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['finished'] = $finished;
            }
        }
        // query params
        if ($unfinished !== null) {
            if('form' === 'form' && is_array($unfinished)) {
                foreach($unfinished as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['unfinished'] = $unfinished;
            }
        }
        // query params
        if ($process_finished !== null) {
            if('form' === 'form' && is_array($process_finished)) {
                foreach($process_finished as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processFinished'] = $process_finished;
            }
        }
        // query params
        if ($process_unfinished !== null) {
            if('form' === 'form' && is_array($process_unfinished)) {
                foreach($process_unfinished as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processUnfinished'] = $process_unfinished;
            }
        }
        // query params
        if ($task_due_date !== null) {
            if('form' === 'form' && is_array($task_due_date)) {
                foreach($task_due_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDueDate'] = $task_due_date;
            }
        }
        // query params
        if ($task_due_date_before !== null) {
            if('form' === 'form' && is_array($task_due_date_before)) {
                foreach($task_due_date_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDueDateBefore'] = $task_due_date_before;
            }
        }
        // query params
        if ($task_due_date_after !== null) {
            if('form' === 'form' && is_array($task_due_date_after)) {
                foreach($task_due_date_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDueDateAfter'] = $task_due_date_after;
            }
        }
        // query params
        if ($without_task_due_date !== null) {
            if('form' === 'form' && is_array($without_task_due_date)) {
                foreach($without_task_due_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutTaskDueDate'] = $without_task_due_date;
            }
        }
        // query params
        if ($task_follow_up_date !== null) {
            if('form' === 'form' && is_array($task_follow_up_date)) {
                foreach($task_follow_up_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskFollowUpDate'] = $task_follow_up_date;
            }
        }
        // query params
        if ($task_follow_up_date_before !== null) {
            if('form' === 'form' && is_array($task_follow_up_date_before)) {
                foreach($task_follow_up_date_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskFollowUpDateBefore'] = $task_follow_up_date_before;
            }
        }
        // query params
        if ($task_follow_up_date_after !== null) {
            if('form' === 'form' && is_array($task_follow_up_date_after)) {
                foreach($task_follow_up_date_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskFollowUpDateAfter'] = $task_follow_up_date_after;
            }
        }
        // query params
        if ($started_before !== null) {
            if('form' === 'form' && is_array($started_before)) {
                foreach($started_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startedBefore'] = $started_before;
            }
        }
        // query params
        if ($started_after !== null) {
            if('form' === 'form' && is_array($started_after)) {
                foreach($started_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startedAfter'] = $started_after;
            }
        }
        // query params
        if ($finished_before !== null) {
            if('form' === 'form' && is_array($finished_before)) {
                foreach($finished_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['finishedBefore'] = $finished_before;
            }
        }
        // query params
        if ($finished_after !== null) {
            if('form' === 'form' && is_array($finished_after)) {
                foreach($finished_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['finishedAfter'] = $finished_after;
            }
        }
        // query params
        if ($tenant_id_in !== null) {
            if('form' === 'form' && is_array($tenant_id_in)) {
                foreach($tenant_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tenantIdIn'] = $tenant_id_in;
            }
        }
        // query params
        if ($without_tenant_id !== null) {
            if('form' === 'form' && is_array($without_tenant_id)) {
                foreach($without_tenant_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutTenantId'] = $without_tenant_id;
            }
        }
        // query params
        if ($task_variables !== null) {
            if('form' === 'form' && is_array($task_variables)) {
                foreach($task_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskVariables'] = $task_variables;
            }
        }
        // query params
        if ($process_variables !== null) {
            if('form' === 'form' && is_array($process_variables)) {
                foreach($process_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processVariables'] = $process_variables;
            }
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_names_ignore_case)) {
                foreach($variable_names_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableNamesIgnoreCase'] = $variable_names_ignore_case;
            }
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_values_ignore_case)) {
                foreach($variable_values_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableValuesIgnoreCase'] = $variable_values_ignore_case;
            }
        }
        // query params
        if ($task_involved_user !== null) {
            if('form' === 'form' && is_array($task_involved_user)) {
                foreach($task_involved_user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskInvolvedUser'] = $task_involved_user;
            }
        }
        // query params
        if ($task_involved_group !== null) {
            if('form' === 'form' && is_array($task_involved_group)) {
                foreach($task_involved_group as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskInvolvedGroup'] = $task_involved_group;
            }
        }
        // query params
        if ($task_had_candidate_user !== null) {
            if('form' === 'form' && is_array($task_had_candidate_user)) {
                foreach($task_had_candidate_user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskHadCandidateUser'] = $task_had_candidate_user;
            }
        }
        // query params
        if ($task_had_candidate_group !== null) {
            if('form' === 'form' && is_array($task_had_candidate_group)) {
                foreach($task_had_candidate_group as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskHadCandidateGroup'] = $task_had_candidate_group;
            }
        }
        // query params
        if ($with_candidate_groups !== null) {
            if('form' === 'form' && is_array($with_candidate_groups)) {
                foreach($with_candidate_groups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withCandidateGroups'] = $with_candidate_groups;
            }
        }
        // query params
        if ($without_candidate_groups !== null) {
            if('form' === 'form' && is_array($without_candidate_groups)) {
                foreach($without_candidate_groups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutCandidateGroups'] = $without_candidate_groups;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryHistoricTaskInstances
     *
     * Get Tasks (Historic) (POST)
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \OpenAPI\Client\Model\HistoricTaskInstanceQueryDto $historic_task_instance_query_dto historic_task_instance_query_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HistoricTaskInstanceDto[]|\OpenAPI\Client\Model\ExceptionDto
     */
    public function queryHistoricTaskInstances($first_result = null, $max_results = null, $historic_task_instance_query_dto = null)
    {
        list($response) = $this->queryHistoricTaskInstancesWithHttpInfo($first_result, $max_results, $historic_task_instance_query_dto);
        return $response;
    }

    /**
     * Operation queryHistoricTaskInstancesWithHttpInfo
     *
     * Get Tasks (Historic) (POST)
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \OpenAPI\Client\Model\HistoricTaskInstanceQueryDto $historic_task_instance_query_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HistoricTaskInstanceDto[]|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryHistoricTaskInstancesWithHttpInfo($first_result = null, $max_results = null, $historic_task_instance_query_dto = null)
    {
        $request = $this->queryHistoricTaskInstancesRequest($first_result, $max_results, $historic_task_instance_query_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\HistoricTaskInstanceDto[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\HistoricTaskInstanceDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\HistoricTaskInstanceDto[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HistoricTaskInstanceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryHistoricTaskInstancesAsync
     *
     * Get Tasks (Historic) (POST)
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \OpenAPI\Client\Model\HistoricTaskInstanceQueryDto $historic_task_instance_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryHistoricTaskInstancesAsync($first_result = null, $max_results = null, $historic_task_instance_query_dto = null)
    {
        return $this->queryHistoricTaskInstancesAsyncWithHttpInfo($first_result, $max_results, $historic_task_instance_query_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryHistoricTaskInstancesAsyncWithHttpInfo
     *
     * Get Tasks (Historic) (POST)
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \OpenAPI\Client\Model\HistoricTaskInstanceQueryDto $historic_task_instance_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryHistoricTaskInstancesAsyncWithHttpInfo($first_result = null, $max_results = null, $historic_task_instance_query_dto = null)
    {
        $returnType = '\OpenAPI\Client\Model\HistoricTaskInstanceDto[]';
        $request = $this->queryHistoricTaskInstancesRequest($first_result, $max_results, $historic_task_instance_query_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryHistoricTaskInstances'
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \OpenAPI\Client\Model\HistoricTaskInstanceQueryDto $historic_task_instance_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queryHistoricTaskInstancesRequest($first_result = null, $max_results = null, $historic_task_instance_query_dto = null)
    {

        $resourcePath = '/history/task';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($first_result !== null) {
            if('form' === 'form' && is_array($first_result)) {
                foreach($first_result as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['firstResult'] = $first_result;
            }
        }
        // query params
        if ($max_results !== null) {
            if('form' === 'form' && is_array($max_results)) {
                foreach($max_results as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxResults'] = $max_results;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($historic_task_instance_query_dto)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($historic_task_instance_query_dto));
            } else {
                $httpBody = $historic_task_instance_query_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryHistoricTaskInstancesCount
     *
     * Get Task Count (POST)
     *
     * @param  \OpenAPI\Client\Model\HistoricTaskInstanceQueryDto $historic_task_instance_query_dto historic_task_instance_query_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CountResultDto|\OpenAPI\Client\Model\ExceptionDto
     */
    public function queryHistoricTaskInstancesCount($historic_task_instance_query_dto = null)
    {
        list($response) = $this->queryHistoricTaskInstancesCountWithHttpInfo($historic_task_instance_query_dto);
        return $response;
    }

    /**
     * Operation queryHistoricTaskInstancesCountWithHttpInfo
     *
     * Get Task Count (POST)
     *
     * @param  \OpenAPI\Client\Model\HistoricTaskInstanceQueryDto $historic_task_instance_query_dto (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CountResultDto|\OpenAPI\Client\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryHistoricTaskInstancesCountWithHttpInfo($historic_task_instance_query_dto = null)
    {
        $request = $this->queryHistoricTaskInstancesCountRequest($historic_task_instance_query_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CountResultDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CountResultDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CountResultDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryHistoricTaskInstancesCountAsync
     *
     * Get Task Count (POST)
     *
     * @param  \OpenAPI\Client\Model\HistoricTaskInstanceQueryDto $historic_task_instance_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryHistoricTaskInstancesCountAsync($historic_task_instance_query_dto = null)
    {
        return $this->queryHistoricTaskInstancesCountAsyncWithHttpInfo($historic_task_instance_query_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryHistoricTaskInstancesCountAsyncWithHttpInfo
     *
     * Get Task Count (POST)
     *
     * @param  \OpenAPI\Client\Model\HistoricTaskInstanceQueryDto $historic_task_instance_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryHistoricTaskInstancesCountAsyncWithHttpInfo($historic_task_instance_query_dto = null)
    {
        $returnType = '\OpenAPI\Client\Model\CountResultDto';
        $request = $this->queryHistoricTaskInstancesCountRequest($historic_task_instance_query_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryHistoricTaskInstancesCount'
     *
     * @param  \OpenAPI\Client\Model\HistoricTaskInstanceQueryDto $historic_task_instance_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queryHistoricTaskInstancesCountRequest($historic_task_instance_query_dto = null)
    {

        $resourcePath = '/history/task/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($historic_task_instance_query_dto)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($historic_task_instance_query_dto));
            } else {
                $httpBody = $historic_task_instance_query_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
